#include <iostream>

void showSlice(int arr[][5][10], int slice){
  for(int i = 0; i < 5; ++i){
    for(int j = 0; j < 5; ++j){
      (arr[i][j][slice+1] == 1) ? (std::cout << "1\t") : (std::cout << "0\t");
    }
    std::cout << std::endl;
  }
}

void fillArr(int arr[][5][10]){
  for(int i = 0; i < 5; ++i){
    for(int j = 0; j < 5; ++j){
      int val = -1;
      while(val < 0 || val > 10){
        std::cout << "[" << i << "][" << j << "] = ";
        std::cin >> val;
        for(int k = 0; k < val; ++k){
          arr[i][j][k] = 1;
        }
      }
    }
  }
}


int main() {
  int landscape[5][5][10] = {0};
  int slice = 0;
  fillArr(landscape);
  std::cout << "Введите срез: ";
  std::cin >> slice;
  showSlice(landscape, slice);
}

/*
Задача 8. Почти-Майнкрафт

Нам всё-таки предстоит сделать некое подобие Майнкрафта. Миллионов не обещаю, но это довольно интересная задача на пространственное мышление. У нас есть небольшой квадратный ландшафт, размером 5х5 секторов. В каждом секторе располагается блок (столбик) ландшафта, максимальная высота которого — это 10 блоков. Текущая высота каждого такого блока задаётся пользователем вначале программы. Итоговая задача — используя трёхмерный массив вывести в стандартный вывод горизонтальное сечение (или горизонтальный срез) нашего небольшого мира. Сам мир как раз должен быть представлен в виде трёхмерного массива. Его горизонтальный срез стало быть — это двумерный массив, который надо отобразить в виде единиц и нулей. 0 — это отсутствие элемента на данном уровне в данной точке, 1 — элемент есть. Уровень среза от 0 до 9 включительно — также задаётся в стандартном вводе.
*/